<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TODOã‚¢ãƒ—ãƒª</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'fade-in': 'fadeIn 0.3s ease-in-out',
                        'slide-in': 'slideIn 0.3s ease-out'
                    }
                }
            }
        }
    </script>
    <style>
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        /* Improve mobile touch targets */
        @media (max-width: 640px) {
            input, button, select {
                font-size: 16px !important; /* Prevents zoom on iOS */
            }
            
            /* Improve tap highlighting */
            button, input[type="checkbox"] {
                -webkit-tap-highlight-color: rgba(59, 130, 246, 0.3);
            }
            
            /* Better scrolling on mobile */
            body {
                -webkit-overflow-scrolling: touch;
                overflow-scrolling: touch;
            }
        }
        
        /* Touch manipulation for better mobile performance */
        .touch-manipulation {
            touch-action: manipulation;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <div class="container mx-auto px-4 py-4 sm:py-8 max-w-2xl">
        <div class="bg-white rounded-2xl shadow-xl p-4 sm:p-8 animate-fade-in">
            <h1 class="text-2xl sm:text-4xl font-bold text-center mb-4 sm:mb-8 text-gray-800 bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                TODOã‚¢ãƒ—ãƒª
            </h1>
            
            <div class="mb-4 sm:mb-8">
                <div class="space-y-3">
                    <div class="flex flex-col sm:flex-row gap-3">
                        <input 
                            type="text" 
                            id="newTask" 
                            placeholder="æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’å…¥åŠ›..." 
                            class="flex-1 px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none transition-colors duration-200 text-gray-700 placeholder-gray-400 text-base"
                        >
                        <select 
                            id="prioritySelect" 
                            class="px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none transition-colors duration-200 text-gray-700 min-w-0 sm:min-w-fit"
                        >
                            <option value="high">ğŸ”´ é«˜</option>
                            <option value="medium" selected>ğŸŸ¡ ä¸­</option>
                            <option value="low">ğŸŸ¢ ä½</option>
                        </select>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-3">
                        <input 
                            type="date" 
                            id="dueDateInput" 
                            class="flex-1 px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none transition-colors duration-200 text-gray-700 text-base"
                            title="æœŸé™æ—¥ã‚’è¨­å®šï¼ˆä»»æ„ï¼‰"
                        >
                        <input 
                            type="text" 
                            id="categoryInput" 
                            placeholder="ã‚«ãƒ†ã‚´ãƒªï¼ˆä»»æ„ï¼‰" 
                            class="flex-1 px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none transition-colors duration-200 text-gray-700 placeholder-gray-400 text-base"
                            list="categoryList"
                            maxlength="50"
                        >
                        <datalist id="categoryList"></datalist>
                        <button 
                            onclick="addTask()" 
                            class="w-full sm:w-auto px-6 sm:px-8 py-3 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-xl hover:from-blue-600 hover:to-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-200 transition-all duration-200 font-medium shadow-lg hover:shadow-xl transform hover:scale-105 text-base touch-manipulation"
                        >
                            è¿½åŠ 
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="mb-6">
                <div class="flex justify-between items-center mb-4">
                    <div class="flex items-center gap-3">
                        <h2 class="text-xl font-semibold text-gray-800">ã‚¿ã‚¹ã‚¯ä¸€è¦§</h2>
                        <div class="flex items-center gap-2">
                            <input 
                                type="checkbox" 
                                id="selectAllCheckbox" 
                                class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded cursor-pointer"
                                onchange="toggleSelectAll()"
                            >
                            <label for="selectAllCheckbox" class="text-sm text-gray-600 cursor-pointer">ã™ã¹ã¦é¸æŠ</label>
                        </div>
                    </div>
                </div>
                
                <!-- Bulk Actions Bar (hidden by default) -->
                <div id="bulkActionsBar" class="bg-blue-50 border border-blue-200 rounded-xl p-3 mb-4 hidden">
                    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
                        <span id="selectedCount" class="text-sm text-blue-700 font-medium text-center sm:text-left">0å€‹ã®ã‚¿ã‚¹ã‚¯ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã™</span>
                        <div class="flex flex-col sm:flex-row gap-2">
                            <button 
                                onclick="bulkComplete()" 
                                class="w-full sm:w-auto px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors duration-200 text-sm font-medium touch-manipulation min-h-[44px] sm:min-h-0"
                            >
                                âœ“ ä¸€æ‹¬å®Œäº†
                            </button>
                            <button 
                                onclick="bulkIncomplete()" 
                                class="w-full sm:w-auto px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 transition-colors duration-200 text-sm font-medium touch-manipulation min-h-[44px] sm:min-h-0"
                            >
                                â†º æœªå®Œäº†ã«æˆ»ã™
                            </button>
                            <button 
                                onclick="bulkDelete()" 
                                class="w-full sm:w-auto px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors duration-200 text-sm font-medium touch-manipulation min-h-[44px] sm:min-h-0"
                            >
                                ğŸ—‘ï¸ ä¸€æ‹¬å‰Šé™¤
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Search and Filter Controls -->
                <div class="bg-gray-50 rounded-xl p-3 sm:p-4 mb-4">
                    <div class="space-y-3 sm:space-y-0 sm:flex sm:flex-wrap sm:gap-3 sm:items-center">
                        <div class="w-full sm:flex-1 sm:min-w-0">
                            <div class="relative">
                                <input 
                                    type="text" 
                                    id="searchInput" 
                                    placeholder="ğŸ” ã‚¿ã‚¹ã‚¯ã‚’æ¤œç´¢..." 
                                    class="w-full px-4 py-3 sm:py-2 pl-10 border-2 border-gray-200 rounded-lg focus:border-blue-500 focus:outline-none transition-colors duration-200 text-gray-700 placeholder-gray-400 text-base"
                                    oninput="debounceSearch()"
                                >
                                <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                    <span class="text-gray-400">ğŸ”</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex flex-col sm:flex-row gap-3 sm:gap-2 sm:items-center">
                            <div class="flex gap-2 items-center">
                                <label for="categoryFilter" class="text-sm text-gray-600 whitespace-nowrap min-w-fit">ã‚«ãƒ†ã‚´ãƒª:</label>
                                <select 
                                    id="categoryFilter" 
                                    onchange="fetchTasks()" 
                                    class="flex-1 sm:flex-none px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:border-blue-500"
                                >
                                    <option value="">ã™ã¹ã¦</option>
                                </select>
                            </div>
                            <div class="flex gap-2 items-center">
                                <label for="sortOrder" class="text-sm text-gray-600 whitespace-nowrap min-w-fit">ä¸¦ã³é †:</label>
                                <select 
                                    id="sortOrder" 
                                    onchange="handleSortChange()" 
                                    class="flex-1 sm:flex-none px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:border-blue-500"
                                >
                                    <option value="priority">å„ªå…ˆåº¦é †</option>
                                    <option value="created">ä½œæˆæ—¥é †</option>
                                    <option value="manual">æ‰‹å‹•ä¸¦ã³æ›¿ãˆ</option>
                                </select>
                            </div>
                            <button 
                                onclick="clearFilters()" 
                                class="w-full sm:w-auto px-3 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors duration-200 text-sm font-medium touch-manipulation"
                            >
                                ğŸ—‘ï¸ ã‚¯ãƒªã‚¢
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <ul id="taskList" class="space-y-3"></ul>
        </div>
    </div>

    <script>
        const BEARER_TOKEN = 'your-secret-token';
        let isDragAndDropEnabled = false;
        let draggedElement = null;
        let draggedTaskId = null;
        
        function getAuthHeaders() {
            return {
                'Authorization': `Bearer ${BEARER_TOKEN}`,
                'Content-Type': 'application/json'
            };
        }
        
        function getPriorityIcon(priority) {
            switch(priority) {
                case 'high': return 'ğŸ”´';
                case 'medium': return 'ğŸŸ¡';
                case 'low': return 'ğŸŸ¢';
                default: return 'ğŸŸ¡';
            }
        }
        
        function getPriorityLabel(priority) {
            switch(priority) {
                case 'high': return 'é«˜';
                case 'medium': return 'ä¸­';
                case 'low': return 'ä½';
                default: return 'ä¸­';
            }
        }
        
        function formatDate(dateString) {
            if (!dateString) return null;
            const date = new Date(dateString);
            return date.toLocaleDateString('ja-JP', { 
                month: 'short', 
                day: 'numeric' 
            });
        }
        
        function getDeadlineStatus(dueDate) {
            if (!dueDate) return null;
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const due = new Date(dueDate);
            due.setHours(0, 0, 0, 0);
            
            const diffTime = due.getTime() - today.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays < 0) return 'overdue';
            if (diffDays === 0) return 'today';
            if (diffDays === 1) return 'tomorrow';
            if (diffDays <= 3) return 'soon';
            return 'normal';
        }
        
        function getDeadlineDisplay(dueDate) {
            if (!dueDate) return '';
            
            const status = getDeadlineStatus(dueDate);
            const formatted = formatDate(dueDate);
            
            switch(status) {
                case 'overdue': return `âš ï¸ æœŸé™åˆ‡ã‚Œ (${formatted})`;
                case 'today': return `ğŸ”¥ ä»Šæ—¥æœŸé™`;
                case 'tomorrow': return `â° æ˜æ—¥æœŸé™`;
                case 'soon': return `ğŸ“… ${formatted}æœŸé™`;
                default: return `ğŸ“… ${formatted}`;
            }
        }
        
        function getCategoryColor(category) {
            if (!category) return null;
            
            // Generate a consistent color based on category name
            let hash = 0;
            for (let i = 0; i < category.length; i++) {
                hash = category.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            const colors = [
                'bg-blue-100 text-blue-800',
                'bg-green-100 text-green-800',
                'bg-purple-100 text-purple-800',
                'bg-pink-100 text-pink-800',
                'bg-indigo-100 text-indigo-800',
                'bg-yellow-100 text-yellow-800',
                'bg-teal-100 text-teal-800',
                'bg-orange-100 text-orange-800'
            ];
            
            return colors[Math.abs(hash) % colors.length];
        }
        
        async function fetchCategories() {
            try {
                const res = await fetch('/categories', {
                    headers: { 'Authorization': `Bearer ${BEARER_TOKEN}` }
                });
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                const categories = await res.json();
                
                // Update category filter dropdown
                const categoryFilter = document.getElementById('categoryFilter');
                const currentValue = categoryFilter.value;
                categoryFilter.innerHTML = '<option value="">ã™ã¹ã¦</option>';
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    categoryFilter.appendChild(option);
                });
                categoryFilter.value = currentValue;
                
                // Update category input datalist
                const categoryList = document.getElementById('categoryList');
                categoryList.innerHTML = '';
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    categoryList.appendChild(option);
                });
            } catch (error) {
                console.error('Error fetching categories:', error);
            }
        }
        
        let searchTimeout;
        
        function debounceSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(fetchTasks, 300);
        }
        
        function clearFilters() {
            document.getElementById('searchInput').value = '';
            document.getElementById('categoryFilter').value = '';
            document.getElementById('sortOrder').value = 'priority';
            isDragAndDropEnabled = false;
            fetchTasks();
        }

        function handleSortChange() {
            const sortOrder = document.getElementById('sortOrder').value;
            isDragAndDropEnabled = sortOrder === 'manual';
            console.log('Sort order changed to:', sortOrder, 'Drag enabled:', isDragAndDropEnabled);
            fetchTasks();
        }

        async function reorderTasks(taskOrders) {
            try {
                console.log('Reordering tasks:', taskOrders);
                const res = await fetch('/tasks/reorder', {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ taskOrders })
                });
                
                if (!res.ok) {
                    if (res.status === 401) {
                        alert('èªè¨¼ã‚¨ãƒ©ãƒ¼: ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ã§ã™');
                        return false;
                    }
                    const errorText = await res.text();
                    console.error('Server error:', res.status, errorText);
                    throw new Error(`HTTP error! status: ${res.status} - ${errorText}`);
                }
                
                const result = await res.json();
                console.log('Reorder result:', result);
                return true;
            } catch (error) {
                console.error('Error reordering tasks:', error);
                alert('ã‚¿ã‚¹ã‚¯ã®ä¸¦ã³æ›¿ãˆã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                return false;
            }
        }

        function makeTaskDraggable(taskElement, task, index) {
            if (!isDragAndDropEnabled) {
                taskElement.draggable = false;
                taskElement.style.cursor = '';
                // Remove drag-related attributes
                taskElement.removeAttribute('data-drag-listeners');
                return taskElement;
            }

            // Check if drag listeners are already attached
            if (taskElement.hasAttribute('data-drag-listeners')) {
                return taskElement;
            }

            console.log('Making task draggable:', task.text, 'ID:', task.id);
            
            // Better mobile support
            const isMobile = window.innerWidth <= 640;
            taskElement.draggable = true;
            taskElement.style.cursor = isMobile ? 'default' : 'grab';
            taskElement.style.touchAction = 'manipulation';
            taskElement.setAttribute('data-drag-listeners', 'true');
            
            // Add visual indicator for mobile drag
            if (isMobile) {
                const dragHandle = document.createElement('div');
                dragHandle.className = 'absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 text-lg sm:hidden';
                dragHandle.innerHTML = 'â‹®â‹®';
                dragHandle.style.pointerEvents = 'none';
                taskElement.style.position = 'relative';
                taskElement.appendChild(dragHandle);
            }
            
            taskElement.addEventListener('dragstart', (e) => {
                draggedElement = taskElement;
                draggedTaskId = task.id;
                taskElement.style.opacity = '0.5';
                taskElement.style.cursor = 'grabbing';
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', task.id.toString());
            });

            taskElement.addEventListener('dragend', (e) => {
                taskElement.style.opacity = '';
                taskElement.style.cursor = 'grab';
                // Clean up visual indicators
                const allElements = document.querySelectorAll('#taskList li');
                allElements.forEach(el => {
                    el.style.borderTop = '';
                    el.style.borderBottom = '';
                });
                draggedElement = null;
                draggedTaskId = null;
            });

            taskElement.addEventListener('dragover', (e) => {
                if (draggedElement && draggedElement !== taskElement) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    // Clear borders on all elements first
                    const allElements = document.querySelectorAll('#taskList li');
                    allElements.forEach(el => {
                        if (el !== taskElement) {
                            el.style.borderTop = '';
                            el.style.borderBottom = '';
                        }
                    });
                    
                    const rect = taskElement.getBoundingClientRect();
                    const midY = rect.top + rect.height / 2;
                    
                    if (e.clientY < midY) {
                        taskElement.style.borderTop = '3px solid #3b82f6';
                        taskElement.style.borderBottom = '';
                    } else {
                        taskElement.style.borderBottom = '3px solid #3b82f6';
                        taskElement.style.borderTop = '';
                    }
                }
            });

            taskElement.addEventListener('drop', async (e) => {
                e.preventDefault();
                
                // Clear all visual indicators
                const allElements = document.querySelectorAll('#taskList li');
                allElements.forEach(el => {
                    el.style.borderTop = '';
                    el.style.borderBottom = '';
                });
                
                if (draggedElement && draggedElement !== taskElement && draggedTaskId) {
                    const allTasks = Array.from(document.querySelectorAll('#taskList li'));
                    const draggedIndex = allTasks.indexOf(draggedElement);
                    const targetIndex = allTasks.indexOf(taskElement);
                    
                    if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== targetIndex) {
                        // Get drop position (before or after target)
                        const rect = taskElement.getBoundingClientRect();
                        const midY = rect.top + rect.height / 2;
                        const insertAfter = e.clientY >= midY;
                        
                        // Create new order array
                        const currentTasks = [];
                        allTasks.forEach(el => {
                            const taskId = parseInt(el.dataset.taskId);
                            if (!isNaN(taskId)) {
                                currentTasks.push(taskId);
                            }
                        });
                        
                        // Remove dragged task from current position
                        const draggedTaskIndex = currentTasks.indexOf(draggedTaskId);
                        if (draggedTaskIndex > -1) {
                            currentTasks.splice(draggedTaskIndex, 1);
                        }
                        
                        // Find target task in the array
                        const targetTaskId = parseInt(taskElement.dataset.taskId);
                        const targetTaskIndex = currentTasks.indexOf(targetTaskId);
                        
                        // Insert dragged task at new position
                        const insertIndex = insertAfter ? targetTaskIndex + 1 : targetTaskIndex;
                        currentTasks.splice(insertIndex, 0, draggedTaskId);
                        
                        // Create task orders array
                        const taskOrders = currentTasks.map((id, index) => ({
                            id: id,
                            sort_order: index + 1
                        }));
                        
                        // Send reorder request to server
                        const success = await reorderTasks(taskOrders);
                        if (success) {
                            fetchTasks(); // Refresh the task list
                        }
                    }
                }
            });
        }

        async function toggleTaskCompletion(index) {
            try {
                const res = await fetch(`/tasks/${index}/toggle`, { 
                    method: 'PATCH',
                    headers: { 'Authorization': `Bearer ${BEARER_TOKEN}` }
                });
                if (!res.ok) {
                    if (res.status === 401) {
                        alert('èªè¨¼ã‚¨ãƒ©ãƒ¼: ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ã§ã™');
                        return;
                    }
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                fetchTasks();
            } catch (error) {
                console.error('Error toggling task completion:', error);
                alert('ã‚¿ã‚¹ã‚¯ã®å®Œäº†çŠ¶æ…‹ã®å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }

        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const taskCheckboxes = document.querySelectorAll('.task-select-checkbox');
            
            taskCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
            
            updateSelectionState();
        }

        function updateSelectionState() {
            const taskCheckboxes = document.querySelectorAll('.task-select-checkbox');
            const checkedCheckboxes = document.querySelectorAll('.task-select-checkbox:checked');
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const bulkActionsBar = document.getElementById('bulkActionsBar');
            const selectedCount = document.getElementById('selectedCount');
            
            const selectedCount_val = checkedCheckboxes.length;
            const totalCount = taskCheckboxes.length;
            
            // Update select all checkbox state
            if (selectedCount_val === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else if (selectedCount_val === totalCount) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            } else {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = true;
            }
            
            // Show/hide bulk actions bar
            if (selectedCount_val > 0) {
                bulkActionsBar.classList.remove('hidden');
                selectedCount.textContent = `${selectedCount_val}å€‹ã®ã‚¿ã‚¹ã‚¯ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã™`;
            } else {
                bulkActionsBar.classList.add('hidden');
            }
        }

        function getSelectedTaskIndices() {
            const checkedCheckboxes = document.querySelectorAll('.task-select-checkbox:checked');
            return Array.from(checkedCheckboxes).map(checkbox => parseInt(checkbox.dataset.taskIndex));
        }

        async function bulkDelete() {
            const selectedIndices = getSelectedTaskIndices();
            if (selectedIndices.length === 0) {
                alert('å‰Šé™¤ã™ã‚‹ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            if (!confirm(`é¸æŠã—ãŸ${selectedIndices.length}å€‹ã®ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }
            
            try {
                const res = await fetch('/tasks/bulk-delete', {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ indices: selectedIndices })
                });
                
                if (!res.ok) {
                    if (res.status === 401) {
                        alert('èªè¨¼ã‚¨ãƒ©ãƒ¼: ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ã§ã™');
                        return;
                    }
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                
                const result = await res.json();
                fetchTasks();
                alert(result.message);
            } catch (error) {
                console.error('Error bulk deleting tasks:', error);
                alert('ä¸€æ‹¬å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }

        async function bulkComplete() {
            const selectedIndices = getSelectedTaskIndices();
            if (selectedIndices.length === 0) {
                alert('å®Œäº†ã™ã‚‹ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            try {
                const res = await fetch('/tasks/bulk-complete', {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ indices: selectedIndices, completed: true })
                });
                
                if (!res.ok) {
                    if (res.status === 401) {
                        alert('èªè¨¼ã‚¨ãƒ©ãƒ¼: ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ã§ã™');
                        return;
                    }
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                
                const result = await res.json();
                fetchTasks();
                alert(result.message);
            } catch (error) {
                console.error('Error bulk completing tasks:', error);
                alert('ä¸€æ‹¬å®Œäº†ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }

        async function bulkIncomplete() {
            const selectedIndices = getSelectedTaskIndices();
            if (selectedIndices.length === 0) {
                alert('æœªå®Œäº†ã«æˆ»ã™ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            try {
                const res = await fetch('/tasks/bulk-complete', {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ indices: selectedIndices, completed: false })
                });
                
                if (!res.ok) {
                    if (res.status === 401) {
                        alert('èªè¨¼ã‚¨ãƒ©ãƒ¼: ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ã§ã™');
                        return;
                    }
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                
                const result = await res.json();
                fetchTasks();
                alert(result.message);
            } catch (error) {
                console.error('Error bulk updating tasks to incomplete:', error);
                alert('ä¸€æ‹¬æœªå®Œäº†æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }

        async function fetchTasks() {
            try {
                const searchQuery = document.getElementById('searchInput')?.value?.trim() || '';
                const categoryFilter = document.getElementById('categoryFilter')?.value || '';
                const sortOrder = document.getElementById('sortOrder')?.value || 'priority';
                
                // Build query parameters
                const params = new URLSearchParams();
                if (searchQuery) params.append('search', searchQuery);
                if (categoryFilter) params.append('category', categoryFilter);
                if (sortOrder === 'manual') params.append('sort', 'manual');
                
                const url = `/tasks${params.toString() ? '?' + params.toString() : ''}`;
                
                const res = await fetch(url, {
                    headers: { 'Authorization': `Bearer ${BEARER_TOKEN}` }
                });
                if (!res.ok) {
                    if (res.status === 401) {
                        alert('èªè¨¼ã‚¨ãƒ©ãƒ¼: ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ã§ã™');
                        return;
                    }
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                let tasks = await res.json();
                
                // Sort tasks based on selected order (backend handles search/category filtering and manual sorting)
                if (sortOrder === 'created') {
                    tasks = tasks.reverse(); // Since they come pre-sorted by priority, reverse for creation order
                }
            
                const list = document.getElementById('taskList');
                list.innerHTML = '';
            
                // Fetch and update categories
                await fetchCategories();
                
                if (tasks.length === 0) {
                    const emptyState = document.createElement('div');
                    emptyState.className = 'text-center py-12 text-gray-500';

                    const icon = document.createElement('div');
                    icon.className = 'text-6xl mb-4';
                    icon.textContent = 'ğŸ“';

                    const msg1 = document.createElement('p');
                    msg1.className = 'text-lg';
                    
                    // Check if it's due to search/filter
                    const searchQuery = document.getElementById('searchInput')?.value?.trim() || '';
                    const categoryFilter = document.getElementById('categoryFilter')?.value || '';
                    
                    if (searchQuery || categoryFilter) {
                        msg1.textContent = 'æ¤œç´¢æ¡ä»¶ã«ä¸€è‡´ã™ã‚‹ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
                    } else {
                        msg1.textContent = 'ã¾ã ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“';
                    }

                    const msg2 = document.createElement('p');
                    msg2.className = 'text-sm';
                    if (searchQuery || categoryFilter) {
                        msg2.textContent = 'æ¤œç´¢æ¡ä»¶ã‚’å¤‰æ›´ã™ã‚‹ã‹ã€æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¦ãã ã•ã„';
                    } else {
                        msg2.textContent = 'ä¸Šã®å…¥åŠ›æ¬„ã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¦ãã ã•ã„';
                    }

                    emptyState.appendChild(icon);
                    emptyState.appendChild(msg1);
                    emptyState.appendChild(msg2);
                    list.appendChild(emptyState);
                    return;
                }
            
            tasks.forEach((task, i) => {
                const li = document.createElement('li');
                li.className = `rounded-xl p-3 sm:p-4 border transition-all duration-200 animate-slide-in ${
                    task.completed 
                        ? 'bg-gray-100 border-gray-300 opacity-75' 
                        : 'bg-gray-50 border-gray-200 hover:border-blue-300'
                }`;
                li.style.animationDelay = `${i * 50}ms`;
                li.dataset.taskId = task.id;

                const wrapper = document.createElement('div');
                wrapper.className = 'flex flex-col sm:flex-row sm:items-center gap-3 sm:gap-0 sm:justify-between';

                const leftSection = document.createElement('div');
                leftSection.className = 'flex items-center flex-1 sm:mr-4';

                // Checkbox for selection
                const selectCheckbox = document.createElement('input');
                selectCheckbox.type = 'checkbox';
                selectCheckbox.className = 'mr-2 h-5 w-5 sm:h-4 sm:w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded cursor-pointer task-select-checkbox touch-manipulation';
                selectCheckbox.dataset.taskIndex = i;
                selectCheckbox.addEventListener('change', updateSelectionState);

                // Checkbox for completion
                const completionCheckbox = document.createElement('input');
                completionCheckbox.type = 'checkbox';
                completionCheckbox.checked = task.completed;
                completionCheckbox.className = 'mr-3 h-6 w-6 sm:h-5 sm:w-5 text-blue-600 focus:ring-blue-500 border-gray-300 rounded cursor-pointer touch-manipulation';
                completionCheckbox.addEventListener('change', () => toggleTaskCompletion(i));

                const taskContent = document.createElement('div');
                taskContent.className = 'flex-1';
                
                const topRow = document.createElement('div');
                topRow.className = 'flex items-center mb-1';
                
                const priorityBadge = document.createElement('span');
                priorityBadge.className = 'inline-flex items-center px-2 py-1 rounded-full text-xs font-medium mr-3';
                priorityBadge.textContent = `${getPriorityIcon(task.priority)} ${getPriorityLabel(task.priority)}`;
                
                // Priority-specific styling
                switch(task.priority) {
                    case 'high':
                        priorityBadge.className += ' bg-red-100 text-red-800';
                        break;
                    case 'medium':
                        priorityBadge.className += ' bg-yellow-100 text-yellow-800';
                        break;
                    case 'low':
                        priorityBadge.className += ' bg-green-100 text-green-800';
                        break;
                    default:
                        priorityBadge.className += ' bg-yellow-100 text-yellow-800';
                }

                const span = document.createElement('span');
                span.className = `font-medium ${task.completed ? 'text-gray-500 line-through' : 'text-gray-800'}`;
                span.textContent = task.text;
                
                topRow.appendChild(priorityBadge);
                
                // Add category badge if exists
                if (task.category) {
                    const categoryBadge = document.createElement('span');
                    categoryBadge.className = `inline-flex items-center px-2 py-1 rounded-full text-xs font-medium mr-3 ${getCategoryColor(task.category)}`;
                    categoryBadge.textContent = `ğŸ·ï¸ ${task.category}`;
                    topRow.appendChild(categoryBadge);
                }
                
                topRow.appendChild(span);
                
                taskContent.appendChild(topRow);
                
                // Add deadline display if exists
                if (task.due_date) {
                    const deadlineRow = document.createElement('div');
                    deadlineRow.className = 'text-sm mt-1';
                    
                    const deadlineSpan = document.createElement('span');
                    const status = getDeadlineStatus(task.due_date);
                    
                    // Style based on deadline status and completion
                    let deadlineClass = '';
                    switch(status) {
                        case 'overdue':
                            deadlineClass = task.completed ? 'text-gray-400' : 'text-red-600 font-semibold';
                            break;
                        case 'today':
                            deadlineClass = task.completed ? 'text-gray-400' : 'text-red-500 font-semibold';
                            break;
                        case 'tomorrow':
                            deadlineClass = task.completed ? 'text-gray-400' : 'text-orange-500 font-medium';
                            break;
                        case 'soon':
                            deadlineClass = task.completed ? 'text-gray-400' : 'text-yellow-600 font-medium';
                            break;
                        default:
                            deadlineClass = task.completed ? 'text-gray-400' : 'text-gray-600';
                    }
                    
                    if (task.completed) {
                        deadlineClass += ' line-through';
                    }
                    
                    deadlineSpan.className = deadlineClass;
                    deadlineSpan.textContent = getDeadlineDisplay(task.due_date);
                    deadlineRow.appendChild(deadlineSpan);
                    taskContent.appendChild(deadlineRow);
                }

                leftSection.appendChild(selectCheckbox);
                leftSection.appendChild(completionCheckbox);
                leftSection.appendChild(taskContent);

                const btnContainer = document.createElement('div');
                btnContainer.className = 'flex gap-2 w-full sm:w-auto';

                const editBtn = document.createElement('button');
                editBtn.className = 'flex-1 sm:flex-none px-4 sm:px-3 py-2 sm:py-1.5 bg-yellow-100 text-yellow-700 rounded-lg hover:bg-yellow-200 transition-colors duration-200 text-sm font-medium touch-manipulation min-h-[44px] sm:min-h-0';
                editBtn.textContent = 'âœï¸ ç·¨é›†';
                editBtn.addEventListener('click', () => editTask(i, task));

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'flex-1 sm:flex-none px-4 sm:px-3 py-2 sm:py-1.5 bg-red-100 text-red-700 rounded-lg hover:bg-red-200 transition-colors duration-200 text-sm font-medium touch-manipulation min-h-[44px] sm:min-h-0';
                deleteBtn.textContent = 'ğŸ—‘ï¸ å‰Šé™¤';
                deleteBtn.addEventListener('click', () => deleteTask(i));

                btnContainer.appendChild(editBtn);
                btnContainer.appendChild(deleteBtn);

                wrapper.appendChild(leftSection);
                wrapper.appendChild(btnContainer);
                li.appendChild(wrapper);

                // Make task draggable if drag and drop is enabled
                makeTaskDraggable(li, task, i);

                list.appendChild(li);
            });
            
            // Reset selection state after updating tasks
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            }
            const bulkActionsBar = document.getElementById('bulkActionsBar');
            if (bulkActionsBar) {
                bulkActionsBar.classList.add('hidden');
            }
            
            } catch (error) {
                console.error('Error fetching tasks:', error);
                alert('ã‚¿ã‚¹ã‚¯ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        async function addTask() {
            const input = document.getElementById('newTask');
            const prioritySelect = document.getElementById('prioritySelect');
            const dueDateInput = document.getElementById('dueDateInput');
            const categoryInput = document.getElementById('categoryInput');
            const task = input.value.trim();
            const priority = prioritySelect.value;
            const dueDate = dueDateInput.value || null;
            const category = categoryInput.value.trim() || null;
            if (!task) return;
            try {
                const requestBody = { task, priority };
                if (dueDate) {
                    requestBody.due_date = dueDate;
                }
                if (category) {
                    requestBody.category = category;
                }
                
                const res = await fetch('/tasks', { 
                    method: 'POST', 
                    headers: getAuthHeaders(), 
                    body: JSON.stringify(requestBody) 
                });
                if (!res.ok) {
                    if (res.status === 401) {
                        alert('èªè¨¼ã‚¨ãƒ©ãƒ¼: ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ã§ã™');
                        return;
                    }
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                input.value = '';
                prioritySelect.value = 'medium';
                dueDateInput.value = '';
                categoryInput.value = '';
                fetchTasks();
            } catch (error) {
                console.error('Error adding task:', error);
                alert('ã‚¿ã‚¹ã‚¯ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        async function deleteTask(index) {
            try {
                const res = await fetch(`/tasks/${index}`, { 
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${BEARER_TOKEN}` }
                });
                if (!res.ok) {
                    if (res.status === 401) {
                        alert('èªè¨¼ã‚¨ãƒ©ãƒ¼: ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ã§ã™');
                        return;
                    }
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                fetchTasks();
            } catch (error) {
                console.error('Error deleting task:', error);
                alert('ã‚¿ã‚¹ã‚¯ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        async function editTask(index, currentTask) {
            const newTask = prompt('ã‚¿ã‚¹ã‚¯ã‚’ç·¨é›†:', currentTask.text);
            if (!newTask || newTask.trim() === currentTask.text) return;
            
            // Priority selection dialog
            const priorityChoice = prompt(
                `å„ªå…ˆåº¦ã‚’é¸æŠã—ã¦ãã ã•ã„:\n1: ğŸ”´ é«˜\n2: ğŸŸ¡ ä¸­\n3: ğŸŸ¢ ä½\n\nç¾åœ¨: ${getPriorityLabel(currentTask.priority)}\n\næ•°å­—ã‚’å…¥åŠ› (1-3):`
            );
            
            let priority = currentTask.priority;
            if (priorityChoice === '1') priority = 'high';
            else if (priorityChoice === '2') priority = 'medium';
            else if (priorityChoice === '3') priority = 'low';
            
            // Due date selection dialog
            const currentDueDate = currentTask.due_date || '';
            const dueDateChoice = prompt(
                `æœŸé™æ—¥ã‚’è¨­å®šã—ã¦ãã ã•ã„ (YYYY-MM-DDå½¢å¼):\n\nç¾åœ¨: ${currentDueDate || 'è¨­å®šãªã—'}\n\nç©ºç™½ã§æœŸé™ãªã—:`
            );
            
            let dueDate = currentTask.due_date;
            if (dueDateChoice !== null) {
                dueDate = dueDateChoice.trim() || null;
            }
            
            // Category selection dialog
            const currentCategory = currentTask.category || '';
            const categoryChoice = prompt(
                `ã‚«ãƒ†ã‚´ãƒªã‚’è¨­å®šã—ã¦ãã ã•ã„:\n\nç¾åœ¨: ${currentCategory || 'è¨­å®šãªã—'}\n\nç©ºç™½ã§ã‚«ãƒ†ã‚´ãƒªãªã—:`
            );
            
            let category = currentTask.category;
            if (categoryChoice !== null) {
                category = categoryChoice.trim() || null;
            }
            
            // Completion status dialog
            const completionChoice = confirm(
                `å®Œäº†çŠ¶æ…‹ã‚’è¨­å®šã—ã¦ãã ã•ã„:\n\nç¾åœ¨: ${currentTask.completed ? 'å®Œäº†' : 'æœªå®Œäº†'}\n\nã€ŒOKã€ã§å®Œäº†ã€ã€Œã‚­ãƒ£ãƒ³ã‚»ãƒ«ã€ã§æœªå®Œäº†`
            );
            
            const completed = completionChoice;
            
            try {
                const requestBody = { task: newTask.trim(), priority, completed };
                if (dueDate !== undefined) {
                    requestBody.due_date = dueDate;
                }
                if (category !== undefined) {
                    requestBody.category = category;
                }
                
                const res = await fetch(`/tasks/${index}`, { 
                    method: 'PUT', 
                    headers: getAuthHeaders(), 
                    body: JSON.stringify(requestBody) 
                });
                if (!res.ok) {
                    if (res.status === 401) {
                        alert('èªè¨¼ã‚¨ãƒ©ãƒ¼: ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ã§ã™');
                        return;
                    }
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                fetchTasks();
            } catch (error) {
                console.error('Error editing task:', error);
                alert('ã‚¿ã‚¹ã‚¯ã®ç·¨é›†ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        
        // Enter key support for adding tasks
        document.addEventListener('DOMContentLoaded', function() {
            const input = document.getElementById('newTask');
            input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addTask();
                }
            });
        });
        fetchTasks();
    </script>
</body>
</html>
