<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="シンプルで使いやすいTODOアプリ。タスク管理、優先度設定、カテゴリ分けが可能">
    <meta name="keywords" content="TODO,タスク管理,生産性,タスクリスト">
    <meta name="theme-color" content="#3b82f6">
    <link rel="manifest" href="/manifest.json">
    <title>TODOアプリ</title>
    <script src="https://cdn.tailwindcss.com" defer></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    animation: {
                        'fade-in': 'fadeIn 0.3s ease-in-out',
                        'slide-in': 'slideIn 0.3s ease-out'
                    }
                }
            }
        }
    </script>
    <style>
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        /* Improve mobile touch targets */
        @media (max-width: 640px) {
            input, button, select {
                font-size: 16px !important; /* Prevents zoom on iOS */
            }
            
            /* Improve tap highlighting */
            button, input[type="checkbox"] {
                -webkit-tap-highlight-color: rgba(59, 130, 246, 0.3);
            }
            
            /* Better scrolling on mobile */
            body {
                -webkit-overflow-scrolling: touch;
            }
        }
        
        /* Touch manipulation for better mobile performance */
        .touch-manipulation {
            touch-action: manipulation;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-gray-900 dark:to-gray-800 min-h-screen transition-colors duration-300">
    <div class="container mx-auto px-4 py-4 sm:py-8 max-w-2xl">
        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-xl p-4 sm:p-8 animate-fade-in transition-colors duration-300">
            <div class="flex justify-between items-center mb-4 sm:mb-8">
                <h1 class="text-2xl sm:text-4xl font-bold text-center flex-1 text-gray-800 dark:text-white bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                    TODOアプリ
                </h1>
                <div class="flex gap-2">
                    <button 
                        onclick="toggleShortcutHelp()"
                        class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors duration-200 touch-manipulation"
                        title="キーボードショートカット (H)"
                    >
                        <span class="text-xl">⌨️</span>
                    </button>
                    <button 
                        id="themeToggle"
                        onclick="toggleTheme()"
                        class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors duration-200 touch-manipulation"
                        title="テーマを切り替え (T)"
                    >
                        <span id="themeIcon" class="text-xl">🌙</span>
                    </button>
                </div>
            </div>
            
            <div class="mb-4 sm:mb-8">
                <div class="space-y-3">
                    <div class="flex flex-col sm:flex-row gap-3">
                        <input 
                            type="text" 
                            id="newTask" 
                            placeholder="新しいタスクを入力..." 
                            class="flex-1 px-4 py-3 border-2 border-gray-200 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-300 rounded-xl focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none transition-colors duration-200 text-gray-700 placeholder-gray-400 text-base"
                        >
                        <select 
                            id="prioritySelect" 
                            class="px-4 py-3 border-2 border-gray-200 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-xl focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none transition-colors duration-200 text-gray-700 min-w-0 sm:min-w-fit"
                        >
                            <option value="high">🔴 高</option>
                            <option value="medium" selected>🟡 中</option>
                            <option value="low">🟢 低</option>
                        </select>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-3">
                        <input 
                            type="date" 
                            id="dueDateInput" 
                            class="flex-1 px-4 py-3 border-2 border-gray-200 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-xl focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none transition-colors duration-200 text-gray-700 text-base"
                            title="期限日を設定（任意）"
                        >
                        <input 
                            type="text" 
                            id="categoryInput" 
                            placeholder="カテゴリ（任意）" 
                            class="flex-1 px-4 py-3 border-2 border-gray-200 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-300 rounded-xl focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none transition-colors duration-200 text-gray-700 placeholder-gray-400 text-base"
                            list="categoryList"
                            maxlength="50"
                        >
                        <datalist id="categoryList"></datalist>
                        <button 
                            onclick="addTask()" 
                            class="w-full sm:w-auto px-6 sm:px-8 py-3 bg-gradient-to-r from-blue-500 to-blue-600 dark:from-blue-600 dark:to-blue-700 text-white rounded-xl hover:from-blue-600 hover:to-blue-700 dark:hover:from-blue-700 dark:hover:to-blue-800 focus:outline-none focus:ring-4 focus:ring-blue-200 dark:focus:ring-blue-800 transition-all duration-200 font-medium shadow-lg hover:shadow-xl transform hover:scale-105 text-base touch-manipulation"
                        >
                            追加
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="mb-6">
                <div class="flex justify-between items-center mb-4">
                    <div class="flex items-center gap-3">
                        <h2 class="text-xl font-semibold text-gray-800 dark:text-white">タスク一覧</h2>
                        <div class="flex items-center gap-2">
                            <input 
                                type="checkbox" 
                                id="selectAllCheckbox" 
                                class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded cursor-pointer"
                                onchange="toggleSelectAll()"
                            >
                            <label for="selectAllCheckbox" class="text-sm text-gray-600 dark:text-gray-300 cursor-pointer">すべて選択</label>
                        </div>
                    </div>
                </div>
                
                <!-- Bulk Actions Bar (hidden by default) -->
                <div id="bulkActionsBar" class="bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-xl p-3 mb-4 hidden">
                    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
                        <span id="selectedCount" class="text-sm text-blue-700 dark:text-blue-300 font-medium text-center sm:text-left">0個のタスクが選択されています</span>
                        <div class="flex flex-col sm:flex-row gap-2">
                            <button 
                                onclick="bulkComplete()" 
                                class="w-full sm:w-auto px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors duration-200 text-sm font-medium touch-manipulation min-h-[44px] sm:min-h-0"
                            >
                                ✓ 一括完了
                            </button>
                            <button 
                                onclick="bulkIncomplete()" 
                                class="w-full sm:w-auto px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 transition-colors duration-200 text-sm font-medium touch-manipulation min-h-[44px] sm:min-h-0"
                            >
                                ↺ 未完了に戻す
                            </button>
                            <button 
                                onclick="bulkDelete()" 
                                class="w-full sm:w-auto px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors duration-200 text-sm font-medium touch-manipulation min-h-[44px] sm:min-h-0"
                            >
                                🗑️ 一括削除
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Search and Filter Controls -->
                <div class="bg-gray-50 dark:bg-gray-700/50 rounded-xl p-3 sm:p-4 mb-4">
                    <div class="space-y-3 sm:space-y-0 sm:flex sm:flex-wrap sm:gap-3 sm:items-center">
                        <div class="w-full sm:flex-1 sm:min-w-0">
                            <div class="relative">
                                <input 
                                    type="text" 
                                    id="searchInput" 
                                    placeholder="🔍 タスクを検索..." 
                                    class="w-full px-4 py-3 sm:py-2 pl-10 border-2 border-gray-200 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-300 rounded-lg focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none transition-colors duration-200 text-gray-700 placeholder-gray-400 text-base"
                                    oninput="debounceSearch()"
                                >
                                <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                    <span class="text-gray-400">🔍</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex flex-col sm:flex-row gap-3 sm:gap-2 sm:items-center">
                            <div class="flex gap-2 items-center">
                                <label for="categoryFilter" class="text-sm text-gray-600 dark:text-gray-300 whitespace-nowrap min-w-fit">カテゴリ:</label>
                                <select 
                                    id="categoryFilter" 
                                    onchange="fetchTasks()" 
                                    class="flex-1 sm:flex-none px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg text-sm focus:outline-none focus:border-blue-500 dark:focus:border-blue-400"
                                >
                                    <option value="">すべて</option>
                                </select>
                            </div>
                            <div class="flex gap-2 items-center">
                                <label for="sortOrder" class="text-sm text-gray-600 dark:text-gray-300 whitespace-nowrap min-w-fit">並び順:</label>
                                <select 
                                    id="sortOrder" 
                                    onchange="handleSortChange()" 
                                    class="flex-1 sm:flex-none px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg text-sm focus:outline-none focus:border-blue-500 dark:focus:border-blue-400"
                                >
                                    <option value="priority">優先度順</option>
                                    <option value="created">作成日順</option>
                                    <option value="manual">手動並び替え</option>
                                </select>
                            </div>
                            <button 
                                onclick="clearFilters()" 
                                class="w-full sm:w-auto px-3 py-2 bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-500 transition-colors duration-200 text-sm font-medium touch-manipulation"
                            >
                                🗑️ クリア
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <ul id="taskList" class="space-y-3"></ul>
        </div>
    </div>

    <!-- Keyboard Shortcuts Help Modal -->
    <div id="shortcutHelpModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-y-auto">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-gray-800 dark:text-white">キーボードショートカット</h2>
                    <button 
                        onclick="toggleShortcutHelp()"
                        class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors duration-200"
                        title="閉じる"
                    >
                        <span class="text-xl">✕</span>
                    </button>
                </div>
                
                <div class="grid gap-6 md:grid-cols-2">
                    <!-- Basic Actions -->
                    <div>
                        <h3 class="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-3">基本操作</h3>
                        <div class="space-y-2">
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">新しいタスクを追加</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">N</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">検索フィールドにフォーカス</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">F</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">テーマ切り替え</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">T</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">フィルターをクリア</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">C</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">ヘルプを表示</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">H</kbd>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Navigation -->
                    <div>
                        <h3 class="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-3">ナビゲーション</h3>
                        <div class="space-y-2">
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">前のタスクを選択</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">↑</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">次のタスクを選択</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">↓</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">選択解除</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">Esc</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">優先度フィルター（高/中/低）</span>
                                <div class="space-x-1">
                                    <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">1</kbd>
                                    <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">2</kbd>
                                    <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">3</kbd>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Task Actions -->
                    <div>
                        <h3 class="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-3">タスク操作</h3>
                        <div class="space-y-2">
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">タスクの完了切り替え</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">Space</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">タスクを編集</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">Enter</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">編集を保存</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">Ctrl+Enter</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">編集をキャンセル</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">Esc</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">タスクを削除</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">Del</kbd>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Bulk Operations -->
                    <div>
                        <h3 class="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-3">一括操作</h3>
                        <div class="space-y-2">
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">すべて選択/解除</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">Ctrl+A</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">選択したタスクを完了</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">Ctrl+S</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">選択したタスクを削除</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">Ctrl+D</kbd>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Input Field Shortcuts -->
                    <div class="md:col-span-2">
                        <h3 class="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-3">入力フィールド</h3>
                        <div class="space-y-2">
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">タスク入力フィールドからタスクを追加</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">Ctrl+Enter</kbd>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-200 dark:border-gray-600">
                                <span class="text-gray-600 dark:text-gray-400">入力フィールドからフォーカスを外す</span>
                                <kbd class="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs font-mono">Esc</kbd>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-600">
                    <p class="text-sm text-gray-500 dark:text-gray-400 text-center">
                        💡 ヒント: 入力フィールドにフォーカスしていない時にキーを押すと、ショートカットが動作します
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast notification container -->
    <div id="toastContainer" class="fixed top-4 right-4 z-50 space-y-2"></div>

    <script>
        const BEARER_TOKEN = 'your-secret-token';
        
        // フロントエンド最適化設定
        class PerformanceOptimizer {
            static init() {
                // サービスワーカーの登録（オフライン対応）
                if ('serviceWorker' in navigator && window.location.protocol === 'https:') {
                    navigator.serviceWorker.register('/sw.js')
                        .then(() => console.log('Service Worker registered'))
                        .catch(err => console.log('Service Worker registration failed:', err));
                }
                
                // プリロード重要リソース
                this.preloadCriticalResources();
                
                // 遅延ローディングの設定
                this.setupLazyLoading();
                
                // パフォーマンス測定
                this.measurePerformance();
            }
            
            static preloadCriticalResources() {
                // CSS/JS の重要リソースをプリロード
                const link = document.createElement('link');
                link.rel = 'preload';
                link.href = 'https://cdn.tailwindcss.com';
                link.as = 'script';
                document.head.appendChild(link);
            }
            
            static setupLazyLoading() {
                // 画像の遅延ローディング（将来的に画像が追加された場合）
                if ('IntersectionObserver' in window) {
                    const imageObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const img = entry.target;
                                img.src = img.dataset.src;
                                img.classList.remove('lazy');
                                imageObserver.unobserve(img);
                            }
                        });
                    });
                    
                    document.querySelectorAll('img[data-src]').forEach(img => {
                        imageObserver.observe(img);
                    });
                }
            }
            
            static measurePerformance() {
                // ページパフォーマンスの測定
                if ('performance' in window) {
                    window.addEventListener('load', () => {
                        setTimeout(() => {
                            const navigation = performance.getEntriesByType('navigation')[0];
                            console.log('Page Load Performance:', {
                                'DOM Content Loaded': navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
                                'Load Complete': navigation.loadEventEnd - navigation.loadEventStart,
                                'Total Load Time': navigation.loadEventEnd - navigation.fetchStart
                            });
                        }, 0);
                    });
                }
            }
        }
        
        // Enhanced Error Handling System
        class ErrorHandler {
            static showToast(message, type = 'error', duration = 5000) {
                const container = document.getElementById('toastContainer');
                if (!container) return;
                
                const toast = document.createElement('div');
                toast.className = `max-w-sm bg-white dark:bg-gray-800 border-l-4 p-4 rounded-lg shadow-lg transform translate-x-full transition-transform duration-300 ease-in-out animate-fade-in`;
                
                switch(type) {
                    case 'error':
                        toast.className += ' border-red-500';
                        break;
                    case 'warning':
                        toast.className += ' border-yellow-500';
                        break;
                    case 'success':
                        toast.className += ' border-green-500';
                        break;
                    case 'info':
                        toast.className += ' border-blue-500';
                        break;
                }
                
                const icon = type === 'error' ? '❌' : 
                           type === 'warning' ? '⚠️' : 
                           type === 'success' ? '✅' : 'ℹ️';
                
                toast.innerHTML = `
                    <div class="flex items-start">
                        <span class="text-lg mr-3">${icon}</span>
                        <div class="flex-1">
                            <p class="text-sm font-medium text-gray-800 dark:text-white">${message}</p>
                        </div>
                        <button onclick="this.parentElement.parentElement.remove()" class="ml-3 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300">
                            <span class="text-sm">✕</span>
                        </button>
                    </div>
                `;
                
                container.appendChild(toast);
                
                // Slide in animation
                setTimeout(() => {
                    toast.classList.remove('translate-x-full');
                }, 100);
                
                // Auto remove
                setTimeout(() => {
                    toast.classList.add('translate-x-full');
                    setTimeout(() => toast.remove(), 300);
                }, duration);
            }
            
            static handleApiError(error, context = '') {
                console.error(`API Error${context ? ` in ${context}` : ''}:`, error);
                
                if (error.response) {
                    // Server responded with error status
                    const errorData = error.response;
                    
                    if (errorData.error && errorData.error.type) {
                        switch(errorData.error.type) {
                            case 'AUTHENTICATION_ERROR':
                                this.showToast('認証に失敗しました。ページを再読み込みしてください。', 'error');
                                break;
                            case 'VALIDATION_ERROR':
                                const details = errorData.error.details;
                                if (Array.isArray(details)) {
                                    details.forEach(detail => this.showToast(detail, 'warning', 7000));
                                } else {
                                    this.showToast(errorData.error.message || '入力内容に問題があります', 'warning');
                                }
                                break;
                            case 'NOT_FOUND_ERROR':
                                this.showToast('指定されたデータが見つかりません', 'error');
                                break;
                            case 'SERVER_ERROR':
                                const requestId = errorData.error.requestId;
                                this.showToast(
                                    `サーバーエラーが発生しました${requestId ? ` (ID: ${requestId})` : ''}`, 
                                    'error',
                                    8000
                                );
                                break;
                            default:
                                this.showToast(errorData.error.message || 'エラーが発生しました', 'error');
                        }
                    } else {
                        // Legacy error format
                        this.showToast(errorData.error || 'エラーが発生しました', 'error');
                    }
                } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    // Network error
                    this.showToast('ネットワーク接続に問題があります。インターネット接続を確認してください。', 'error', 8000);
                } else if (error.name === 'AbortError') {
                    // Request was aborted
                    this.showToast('リクエストがタイムアウトしました', 'warning');
                } else {
                    // Other errors
                    this.showToast(`エラーが発生しました: ${error.message}`, 'error');
                }
            }
            
            static async fetchWithRetry(url, options = {}, maxRetries = 3, delay = 1000) {
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                        
                        const response = await fetch(url, {
                            ...options,
                            signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (!response.ok) {
                            let errorData;
                            try {
                                errorData = await response.json();
                            } catch {
                                errorData = { error: `HTTP ${response.status}: ${response.statusText}` };
                            }
                            
                            const error = new Error(`HTTP ${response.status}`);
                            error.response = errorData;
                            error.status = response.status;
                            throw error;
                        }
                        
                        return response;
                    } catch (error) {
                        if (attempt === maxRetries) {
                            throw error;
                        }
                        
                        // Don't retry on client errors (4xx) except for 408, 429
                        if (error.status >= 400 && error.status < 500 && 
                            error.status !== 408 && error.status !== 429) {
                            throw error;
                        }
                        
                        console.warn(`Attempt ${attempt} failed, retrying in ${delay}ms...`, error.message);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; // Exponential backoff
                    }
                }
            }
            
            static showSuccess(message) {
                this.showToast(message, 'success', 3000);
            }
            
            static showWarning(message) {
                this.showToast(message, 'warning', 4000);
            }
            
            static showInfo(message) {
                this.showToast(message, 'info', 3000);
            }
            
            static showError(message) {
                this.showToast(message, 'error', 5000);
            }
        }
        let isDragAndDropEnabled = false;
        let draggedElement = null;
        let draggedTaskId = null;
        
        // Theme management
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const shouldUseDark = savedTheme === 'dark' || (!savedTheme && systemPrefersDark);
            
            if (shouldUseDark) {
                document.documentElement.classList.add('dark');
                updateThemeIcon(true);
            } else {
                document.documentElement.classList.remove('dark');
                updateThemeIcon(false);
            }
        }
        
        function toggleTheme() {
            const isDark = document.documentElement.classList.contains('dark');
            
            if (isDark) {
                document.documentElement.classList.remove('dark');
                localStorage.setItem('theme', 'light');
                updateThemeIcon(false);
            } else {
                document.documentElement.classList.add('dark');
                localStorage.setItem('theme', 'dark');
                updateThemeIcon(true);
            }
        }
        
        function updateThemeIcon(isDark) {
            const themeIcon = document.getElementById('themeIcon');
            if (themeIcon) {
                themeIcon.textContent = isDark ? '☀️' : '🌙';
            }
        }
        
        // Initialize theme on page load
        initializeTheme();
        
        // Keyboard shortcuts management
        let selectedTaskIndex = -1;
        let isShortcutHelpVisible = false;
        
        function handleKeyboardShortcuts(e) {
            // Don't interfere with typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                // Allow Escape to clear focus from input fields
                if (e.key === 'Escape') {
                    e.target.blur();
                    return;
                }
                // Allow Ctrl+Enter to add task when in input field
                if (e.key === 'Enter' && e.ctrlKey && e.target.id === 'newTask') {
                    e.preventDefault();
                    addTask();
                    return;
                }
                return;
            }
            
            // Prevent default for handled shortcuts
            const shortcutsToPrevent = ['n', 'a', 'f', 's', 't', 'd', 'h', '?', ' ', 'Enter', 'Delete', 'Backspace'];
            if (shortcutsToPrevent.includes(e.key) || 
                (e.key >= '1' && e.key <= '9') ||
                (e.ctrlKey && ['a', 'f', 's'].includes(e.key.toLowerCase()))) {
                e.preventDefault();
            }
            
            // Handle shortcuts
            if (e.ctrlKey || e.metaKey) {
                switch(e.key.toLowerCase()) {
                    case 'n':
                        focusNewTaskInput();
                        break;
                    case 'f':
                        focusSearchInput();
                        break;
                    case 'a':
                        toggleSelectAllTasks();
                        break;
                    case 's':
                        if (getSelectedTaskIds().length > 0) {
                            bulkComplete();
                        }
                        break;
                    case 'd':
                        if (getSelectedTaskIds().length > 0) {
                            bulkDelete();
                        }
                        break;
                    case 't':
                        toggleTheme();
                        break;
                }
                return;
            }
            
            switch(e.key) {
                case 'n':
                case 'a':
                    focusNewTaskInput();
                    break;
                case 'f':
                case 's':
                    focusSearchInput();
                    break;
                case 't':
                    toggleTheme();
                    break;
                case 'h':
                case '?':
                    toggleShortcutHelp();
                    break;
                case 'ArrowUp':
                    navigateTask(-1);
                    break;
                case 'ArrowDown':
                    navigateTask(1);
                    break;
                case ' ':
                    if (selectedTaskIndex >= 0) {
                        toggleTaskCompletion(selectedTaskIndex);
                    }
                    break;
                case 'Enter':
                    if (selectedTaskIndex >= 0) {
                        const tasks = document.querySelectorAll('#taskList li');
                        if (tasks[selectedTaskIndex]) {
                            const task = getCurrentTaskData(selectedTaskIndex);
                            if (task) {
                                editTask(selectedTaskIndex, task);
                            }
                        }
                    }
                    break;
                case 'Delete':
                case 'Backspace':
                    if (selectedTaskIndex >= 0) {
                        deleteTask(selectedTaskIndex);
                    }
                    break;
                case 'Escape':
                    clearTaskSelection();
                    if (isShortcutHelpVisible) {
                        toggleShortcutHelp();
                    }
                    break;
                // Number keys for priority filter
                case '1':
                case '2':
                case '3':
                    setPriorityFilter(e.key);
                    break;
                // Clear filters
                case 'c':
                    clearFilters();
                    break;
            }
        }
        
        // Helper functions for keyboard shortcuts
        function focusNewTaskInput() {
            const input = document.getElementById('newTask');
            if (input) {
                input.focus();
                input.select();
            }
        }
        
        function focusSearchInput() {
            const input = document.getElementById('searchInput');
            if (input) {
                input.focus();
                input.select();
            }
        }
        
        function toggleSelectAllTasks() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            if (selectAllCheckbox) {
                selectAllCheckbox.click();
            }
        }
        
        function navigateTask(direction) {
            const tasks = document.querySelectorAll('#taskList li');
            if (tasks.length === 0) return;
            
            const newIndex = Math.max(0, Math.min(tasks.length - 1, selectedTaskIndex + direction));
            selectTask(newIndex);
        }
        
        function selectTask(index) {
            clearTaskSelection();
            const tasks = document.querySelectorAll('#taskList li');
            if (tasks[index]) {
                selectedTaskIndex = index;
                tasks[index].classList.add('ring-2', 'ring-blue-500', 'ring-offset-2');
                tasks[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        
        function clearTaskSelection() {
            const tasks = document.querySelectorAll('#taskList li');
            tasks.forEach(task => {
                task.classList.remove('ring-2', 'ring-blue-500', 'ring-offset-2');
            });
            selectedTaskIndex = -1;
        }
        
        function getCurrentTaskData(index) {
            // This would need to access the task data from the current tasks array
            // For now, we'll use a workaround
            const taskElement = document.querySelectorAll('#taskList li')[index];
            if (!taskElement) return null;
            
            const taskId = parseInt(taskElement.dataset.taskId);
            const text = taskElement.querySelector('span').textContent;
            const completed = taskElement.querySelector('input[type="checkbox"]:not(.task-select-checkbox)').checked;
            
            return { id: taskId, text, completed };
        }
        
        function setPriorityFilter(priority) {
            const priorityMap = { '1': 'high', '2': 'medium', '3': 'low' };
            // Set priority in the sort order dropdown - this is a simple implementation
            // In a real app, you might want a separate priority filter
            const sortOrder = document.getElementById('sortOrder');
            if (sortOrder) {
                // For now, just focus on the sort dropdown to indicate the action
                sortOrder.focus();
                console.log(`Priority filter shortcut pressed: ${priorityMap[priority]}`);
            }
        }
        
        function toggleShortcutHelp() {
            const modal = document.getElementById('shortcutHelpModal');
            if (!modal) return;
            
            if (isShortcutHelpVisible) {
                modal.classList.add('hidden');
                modal.classList.remove('flex');
                isShortcutHelpVisible = false;
            } else {
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                isShortcutHelpVisible = true;
            }
        }
        
        // Add keyboard event listener
        document.addEventListener('keydown', handleKeyboardShortcuts);
        
        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('shortcutHelpModal');
            if (modal && isShortcutHelpVisible && e.target === modal) {
                toggleShortcutHelp();
            }
        });
        
        function getAuthHeaders() {
            return {
                'Authorization': `Bearer ${BEARER_TOKEN}`,
                'Content-Type': 'application/json'
            };
        }
        
        function getPriorityIcon(priority) {
            switch(priority) {
                case 'high': return '🔴';
                case 'medium': return '🟡';
                case 'low': return '🟢';
                default: return '🟡';
            }
        }
        
        function getPriorityLabel(priority) {
            switch(priority) {
                case 'high': return '高';
                case 'medium': return '中';
                case 'low': return '低';
                default: return '中';
            }
        }
        
        function formatDate(dateString) {
            if (!dateString) return null;
            const date = new Date(dateString);
            return date.toLocaleDateString('ja-JP', { 
                month: 'short', 
                day: 'numeric' 
            });
        }
        
        function getDeadlineStatus(dueDate) {
            if (!dueDate) return null;
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const due = new Date(dueDate);
            due.setHours(0, 0, 0, 0);
            
            const diffTime = due.getTime() - today.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays < 0) return 'overdue';
            if (diffDays === 0) return 'today';
            if (diffDays === 1) return 'tomorrow';
            if (diffDays <= 3) return 'soon';
            return 'normal';
        }
        
        function getDeadlineDisplay(dueDate) {
            if (!dueDate) return '';
            
            const status = getDeadlineStatus(dueDate);
            const formatted = formatDate(dueDate);
            
            switch(status) {
                case 'overdue': return `⚠️ 期限切れ (${formatted})`;
                case 'today': return `🔥 今日期限`;
                case 'tomorrow': return `⏰ 明日期限`;
                case 'soon': return `📅 ${formatted}期限`;
                default: return `📅 ${formatted}`;
            }
        }
        
        function getCategoryColor(category) {
            if (!category) return null;
            
            // Generate a consistent color based on category name
            let hash = 0;
            for (let i = 0; i < category.length; i++) {
                hash = category.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            const colors = [
                'bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-300',
                'bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300',
                'bg-purple-100 dark:bg-purple-900/30 text-purple-800 dark:text-purple-300',
                'bg-pink-100 dark:bg-pink-900/30 text-pink-800 dark:text-pink-300',
                'bg-indigo-100 dark:bg-indigo-900/30 text-indigo-800 dark:text-indigo-300',
                'bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-300',
                'bg-teal-100 dark:bg-teal-900/30 text-teal-800 dark:text-teal-300',
                'bg-orange-100 dark:bg-orange-900/30 text-orange-800 dark:text-orange-300'
            ];
            
            return colors[Math.abs(hash) % colors.length];
        }
        
        async function fetchCategories() {
            try {
                const res = await ErrorHandler.fetchWithRetry('/categories', {
                    headers: { 'Authorization': `Bearer ${BEARER_TOKEN}` }
                });
                const categories = await res.json();
                
                // Update category filter dropdown
                const categoryFilter = document.getElementById('categoryFilter');
                const currentValue = categoryFilter.value;
                categoryFilter.innerHTML = '<option value="">すべて</option>';
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    categoryFilter.appendChild(option);
                });
                categoryFilter.value = currentValue;
                
                // Update category input datalist
                const categoryList = document.getElementById('categoryList');
                categoryList.innerHTML = '';
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    categoryList.appendChild(option);
                });
            } catch (error) {
                console.error('Error fetching categories:', error);
                // Don't show error toast for categories as it's not critical
            }
        }
        
        let searchTimeout;
        
        function debounceSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(fetchTasks, 300);
        }
        
        function clearFilters() {
            document.getElementById('searchInput').value = '';
            document.getElementById('categoryFilter').value = '';
            document.getElementById('sortOrder').value = 'priority';
            // ソート順をpriorityに戻すので、ドラッグ&ドロップを無効にする
            isDragAndDropEnabled = false;
            fetchTasks();
        }

        function handleSortChange() {
            const sortOrder = document.getElementById('sortOrder').value;
            const previousDragState = isDragAndDropEnabled;
            isDragAndDropEnabled = sortOrder === 'manual';
            console.log('Sort order changed to:', sortOrder, 'Drag enabled:', isDragAndDropEnabled, 'Previous state:', previousDragState);
            
            // ソート順が変更された場合はタスクを再取得
            fetchTasks();
        }

        async function reorderTasks(taskOrders) {
            try {
                console.log('Reordering tasks:', taskOrders);
                const res = await ErrorHandler.fetchWithRetry('/tasks/reorder', {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ taskOrders })
                });
                
                const result = await res.json();
                console.log('Reorder result:', result);
                ErrorHandler.showSuccess('タスクの並び順を更新しました');
                return true;
            } catch (error) {
                ErrorHandler.handleApiError(error, 'reorderTasks');
                return false;
            }
        }

        function makeTaskDraggable(taskElement, task, index) {
            // 既存のドラッグハンドルを削除
            const existingHandle = taskElement.querySelector('.drag-handle');
            if (existingHandle) {
                existingHandle.remove();
            }
            
            // ドラッグ関連の古い属性をリセット
            taskElement.draggable = false;
            taskElement.style.cursor = '';
            taskElement.style.borderLeft = '';
            
            if (!isDragAndDropEnabled) {
                console.log('Drag and drop disabled for task:', task.text);
                return taskElement;
            }

            console.log('Making task draggable:', task.text, 'ID:', task.id);
            
            // Better mobile support
            const isMobile = window.innerWidth <= 640;
            taskElement.draggable = true;
            taskElement.style.cursor = isMobile ? 'default' : 'grab';
            taskElement.style.touchAction = 'manipulation';
            taskElement.setAttribute('data-drag-listeners', 'true');
            
            // ドラッグ可能であることを示すために枠線を追加
            taskElement.style.borderLeft = '4px solid #3b82f6';
            
            // Add visual indicator for drag handle
            const dragHandle = document.createElement('div');
            dragHandle.className = 'drag-handle absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 text-lg';
            dragHandle.innerHTML = '⋮⋮';
            dragHandle.style.pointerEvents = 'none';
            dragHandle.title = 'ドラッグして並び替え';
            taskElement.style.position = 'relative';
            taskElement.appendChild(dragHandle);
            
            taskElement.addEventListener('dragstart', (e) => {
                draggedElement = taskElement;
                draggedTaskId = task.id;
                taskElement.style.opacity = '0.5';
                taskElement.style.cursor = 'grabbing';
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', task.id.toString());
            });

            taskElement.addEventListener('dragend', (e) => {
                taskElement.style.opacity = '';
                taskElement.style.cursor = 'grab';
                // Clean up visual indicators
                const allElements = document.querySelectorAll('#taskList li');
                allElements.forEach(el => {
                    el.style.borderTop = '';
                    el.style.borderBottom = '';
                });
                draggedElement = null;
                draggedTaskId = null;
            });

            taskElement.addEventListener('dragover', (e) => {
                if (draggedElement && draggedElement !== taskElement) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    // Clear borders on all elements first
                    const allElements = document.querySelectorAll('#taskList li');
                    allElements.forEach(el => {
                        if (el !== taskElement) {
                            el.style.borderTop = '';
                            el.style.borderBottom = '';
                        }
                    });
                    
                    const rect = taskElement.getBoundingClientRect();
                    const midY = rect.top + rect.height / 2;
                    
                    if (e.clientY < midY) {
                        taskElement.style.borderTop = '3px solid #3b82f6';
                        taskElement.style.borderBottom = '';
                    } else {
                        taskElement.style.borderBottom = '3px solid #3b82f6';
                        taskElement.style.borderTop = '';
                    }
                }
            });

            taskElement.addEventListener('drop', async (e) => {
                e.preventDefault();
                
                // Clear all visual indicators
                const allElements = document.querySelectorAll('#taskList li');
                allElements.forEach(el => {
                    el.style.borderTop = '';
                    el.style.borderBottom = '';
                });
                
                if (draggedElement && draggedElement !== taskElement && draggedTaskId) {
                    const allTasks = Array.from(document.querySelectorAll('#taskList li'));
                    const draggedIndex = allTasks.indexOf(draggedElement);
                    const targetIndex = allTasks.indexOf(taskElement);
                    
                    if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== targetIndex) {
                        // Get drop position (before or after target)
                        const rect = taskElement.getBoundingClientRect();
                        const midY = rect.top + rect.height / 2;
                        const insertAfter = e.clientY >= midY;
                        
                        // Create new order array
                        const currentTasks = [];
                        allTasks.forEach(el => {
                            const taskId = parseInt(el.dataset.taskId);
                            if (!isNaN(taskId)) {
                                currentTasks.push(taskId);
                            }
                        });
                        
                        // Remove dragged task from current position
                        const draggedTaskIndex = currentTasks.indexOf(draggedTaskId);
                        if (draggedTaskIndex > -1) {
                            currentTasks.splice(draggedTaskIndex, 1);
                        }
                        
                        // Find target task in the array
                        const targetTaskId = parseInt(taskElement.dataset.taskId);
                        const targetTaskIndex = currentTasks.indexOf(targetTaskId);
                        
                        // Insert dragged task at new position
                        const insertIndex = insertAfter ? targetTaskIndex + 1 : targetTaskIndex;
                        currentTasks.splice(insertIndex, 0, draggedTaskId);
                        
                        // Create task orders array
                        const taskOrders = currentTasks.map((id, index) => ({
                            id: id,
                            sort_order: index + 1
                        }));
                        
                        // Send reorder request to server
                        const success = await reorderTasks(taskOrders);
                        if (success) {
                            fetchTasks(); // Refresh the task list
                        }
                    }
                }
            });
        }

        async function toggleTaskCompletion(index) {
            try {
                // Get the task ID from the DOM element
                const taskElement = document.querySelectorAll('#taskList li')[index];
                const taskId = parseInt(taskElement.dataset.taskId);
                
                if (!taskId) {
                    ErrorHandler.showError('タスクIDが見つかりません');
                    return;
                }
                
                const res = await ErrorHandler.fetchWithRetry(`/tasks/${taskId}`, { 
                    method: 'PATCH',
                    headers: { 'Authorization': `Bearer ${BEARER_TOKEN}` }
                });
                
                fetchTasks();
            } catch (error) {
                ErrorHandler.handleApiError(error, 'toggleTaskCompletion');
            }
        }

        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const taskCheckboxes = document.querySelectorAll('.task-select-checkbox');
            
            taskCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
            
            updateSelectionState();
        }

        function updateSelectionState() {
            const taskCheckboxes = document.querySelectorAll('.task-select-checkbox');
            const checkedCheckboxes = document.querySelectorAll('.task-select-checkbox:checked');
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const bulkActionsBar = document.getElementById('bulkActionsBar');
            const selectedCount = document.getElementById('selectedCount');
            
            const selectedCount_val = checkedCheckboxes.length;
            const totalCount = taskCheckboxes.length;
            
            // Update select all checkbox state
            if (selectedCount_val === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else if (selectedCount_val === totalCount) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            } else {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = true;
            }
            
            // Show/hide bulk actions bar
            if (selectedCount_val > 0) {
                bulkActionsBar.classList.remove('hidden');
                selectedCount.textContent = `${selectedCount_val}個のタスクが選択されています`;
            } else {
                bulkActionsBar.classList.add('hidden');
            }
        }

        function getSelectedTaskIds() {
            const checkedCheckboxes = document.querySelectorAll('.task-select-checkbox:checked');
            return Array.from(checkedCheckboxes).map(checkbox => {
                const taskElement = checkbox.closest('li');
                return parseInt(taskElement.dataset.taskId);
            }).filter(id => !isNaN(id));
        }

        async function bulkDelete() {
            const selectedIds = getSelectedTaskIds();
            if (selectedIds.length === 0) {
                ErrorHandler.showWarning('削除するタスクを選択してください');
                return;
            }
            
            if (!confirm(`選択した${selectedIds.length}個のタスクを削除しますか？`)) {
                return;
            }
            
            try {
                const res = await ErrorHandler.fetchWithRetry('/tasks', {
                    method: 'DELETE',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ ids: selectedIds })
                });
                
                const result = await res.json();
                fetchTasks();
                ErrorHandler.showSuccess(`${result.deleted}個のタスクを削除しました`);
            } catch (error) {
                ErrorHandler.handleApiError(error, 'bulkDelete');
            }
        }

        async function bulkComplete() {
            const selectedIds = getSelectedTaskIds();
            if (selectedIds.length === 0) {
                ErrorHandler.showWarning('完了するタスクを選択してください');
                return;
            }
            
            try {
                const res = await ErrorHandler.fetchWithRetry('/tasks', {
                    method: 'PATCH',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ ids: selectedIds, completed: true })
                });
                
                const result = await res.json();
                fetchTasks();
                ErrorHandler.showSuccess(`${result.updated}個のタスクを完了にしました`);
            } catch (error) {
                ErrorHandler.handleApiError(error, 'bulkComplete');
            }
        }

        async function bulkIncomplete() {
            const selectedIds = getSelectedTaskIds();
            if (selectedIds.length === 0) {
                ErrorHandler.showWarning('未完了に戻すタスクを選択してください');
                return;
            }
            
            try {
                const res = await ErrorHandler.fetchWithRetry('/tasks', {
                    method: 'PATCH',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ ids: selectedIds, completed: false })
                });
                
                const result = await res.json();
                fetchTasks();
                ErrorHandler.showSuccess(`${result.updated}個のタスクを未完了に戻しました`);
            } catch (error) {
                ErrorHandler.handleApiError(error, 'bulkIncomplete');
            }
        }

        async function fetchTasks() {
            try {
                const searchQuery = document.getElementById('searchInput')?.value?.trim() || '';
                const categoryFilter = document.getElementById('categoryFilter')?.value || '';
                const sortOrder = document.getElementById('sortOrder')?.value || 'priority';
                
                // Build query parameters
                const params = new URLSearchParams();
                if (searchQuery) params.append('search', searchQuery);
                if (categoryFilter) params.append('category', categoryFilter);
                if (sortOrder === 'manual') params.append('sort', 'manual');
                
                const url = `/tasks${params.toString() ? '?' + params.toString() : ''}`;
                
                const res = await ErrorHandler.fetchWithRetry(url, {
                    headers: { 'Authorization': `Bearer ${BEARER_TOKEN}` }
                });
                let tasks = await res.json();
                
                // Sort tasks based on selected order (backend handles search/category filtering and manual sorting)
                if (sortOrder === 'created') {
                    tasks = tasks.reverse(); // Since they come pre-sorted by priority, reverse for creation order
                }
            
                const list = document.getElementById('taskList');
                list.innerHTML = '';
            
                // Fetch and update categories
                await fetchCategories();
                
                if (tasks.length === 0) {
                    const emptyState = document.createElement('div');
                    emptyState.className = 'text-center py-12 text-gray-500 dark:text-gray-400';

                    const icon = document.createElement('div');
                    icon.className = 'text-6xl mb-4';
                    icon.textContent = '📝';

                    const msg1 = document.createElement('p');
                    msg1.className = 'text-lg';
                    
                    // Check if it's due to search/filter
                    const searchQuery = document.getElementById('searchInput')?.value?.trim() || '';
                    const categoryFilter = document.getElementById('categoryFilter')?.value || '';
                    
                    if (searchQuery || categoryFilter) {
                        msg1.textContent = '検索条件に一致するタスクが見つかりません';
                    } else {
                        msg1.textContent = 'まだタスクがありません';
                    }

                    const msg2 = document.createElement('p');
                    msg2.className = 'text-sm';
                    if (searchQuery || categoryFilter) {
                        msg2.textContent = '検索条件を変更するか、新しいタスクを追加してください';
                    } else {
                        msg2.textContent = '上の入力欄からタスクを追加してください';
                    }

                    emptyState.appendChild(icon);
                    emptyState.appendChild(msg1);
                    emptyState.appendChild(msg2);
                    list.appendChild(emptyState);
                    return;
                }
            
            console.log('Rendering tasks with drag enabled:', isDragAndDropEnabled, 'Task count:', tasks.length);
            
            tasks.forEach((task, i) => {
                const li = document.createElement('li');
                li.className = `rounded-xl p-3 sm:p-4 border transition-all duration-200 animate-slide-in ${
                    task.completed 
                        ? 'bg-gray-100 dark:bg-gray-700 border-gray-300 dark:border-gray-600 opacity-75' 
                        : 'bg-gray-50 dark:bg-gray-700/50 border-gray-200 dark:border-gray-600 hover:border-blue-300 dark:hover:border-blue-500'
                }`;
                li.style.animationDelay = `${i * 50}ms`;
                li.dataset.taskId = task.id;

                const wrapper = document.createElement('div');
                wrapper.className = 'flex flex-col sm:flex-row sm:items-center gap-3 sm:gap-0 sm:justify-between';

                const leftSection = document.createElement('div');
                leftSection.className = 'flex items-center flex-1 sm:mr-4';

                // Checkbox for selection
                const selectCheckbox = document.createElement('input');
                selectCheckbox.type = 'checkbox';
                selectCheckbox.className = 'mr-2 h-5 w-5 sm:h-4 sm:w-4 text-purple-600 focus:ring-purple-500 border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:checked:bg-purple-600 rounded cursor-pointer task-select-checkbox touch-manipulation';
                selectCheckbox.dataset.taskIndex = i;
                selectCheckbox.addEventListener('change', updateSelectionState);

                // Checkbox for completion
                const completionCheckbox = document.createElement('input');
                completionCheckbox.type = 'checkbox';
                completionCheckbox.checked = task.completed;
                completionCheckbox.className = 'mr-3 h-6 w-6 sm:h-5 sm:w-5 text-blue-600 focus:ring-blue-500 border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:checked:bg-blue-600 rounded cursor-pointer touch-manipulation';
                completionCheckbox.addEventListener('change', () => toggleTaskCompletion(i));

                const taskContent = document.createElement('div');
                taskContent.className = 'flex-1';
                
                const topRow = document.createElement('div');
                topRow.className = 'flex items-center mb-1';
                
                const priorityBadge = document.createElement('span');
                priorityBadge.className = 'inline-flex items-center px-2 py-1 rounded-full text-xs font-medium mr-3';
                priorityBadge.textContent = `${getPriorityIcon(task.priority)} ${getPriorityLabel(task.priority)}`;
                
                // Priority-specific styling
                switch(task.priority) {
                    case 'high':
                        priorityBadge.className += ' bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-300';
                        break;
                    case 'medium':
                        priorityBadge.className += ' bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-300';
                        break;
                    case 'low':
                        priorityBadge.className += ' bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300';
                        break;
                    default:
                        priorityBadge.className += ' bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-300';
                }

                const span = document.createElement('span');
                span.className = `font-medium ${task.completed ? 'text-gray-500 dark:text-gray-400 line-through' : 'text-gray-800 dark:text-white'}`;
                span.textContent = task.text;
                
                topRow.appendChild(priorityBadge);
                
                // Add category badge if exists
                if (task.category) {
                    const categoryBadge = document.createElement('span');
                    categoryBadge.className = `inline-flex items-center px-2 py-1 rounded-full text-xs font-medium mr-3 ${getCategoryColor(task.category)}`;
                    categoryBadge.textContent = `🏷️ ${task.category}`;
                    topRow.appendChild(categoryBadge);
                }
                
                topRow.appendChild(span);
                
                taskContent.appendChild(topRow);
                
                // Add deadline display if exists
                if (task.due_date) {
                    const deadlineRow = document.createElement('div');
                    deadlineRow.className = 'text-sm mt-1';
                    
                    const deadlineSpan = document.createElement('span');
                    const status = getDeadlineStatus(task.due_date);
                    
                    // Style based on deadline status and completion
                    let deadlineClass = '';
                    switch(status) {
                        case 'overdue':
                            deadlineClass = task.completed ? 'text-gray-400 dark:text-gray-500' : 'text-red-600 dark:text-red-400 font-semibold';
                            break;
                        case 'today':
                            deadlineClass = task.completed ? 'text-gray-400 dark:text-gray-500' : 'text-red-500 dark:text-red-400 font-semibold';
                            break;
                        case 'tomorrow':
                            deadlineClass = task.completed ? 'text-gray-400 dark:text-gray-500' : 'text-orange-500 dark:text-orange-400 font-medium';
                            break;
                        case 'soon':
                            deadlineClass = task.completed ? 'text-gray-400 dark:text-gray-500' : 'text-yellow-600 dark:text-yellow-400 font-medium';
                            break;
                        default:
                            deadlineClass = task.completed ? 'text-gray-400 dark:text-gray-500' : 'text-gray-600 dark:text-gray-300';
                    }
                    
                    if (task.completed) {
                        deadlineClass += ' line-through';
                    }
                    
                    deadlineSpan.className = deadlineClass;
                    deadlineSpan.textContent = getDeadlineDisplay(task.due_date);
                    deadlineRow.appendChild(deadlineSpan);
                    taskContent.appendChild(deadlineRow);
                }

                leftSection.appendChild(selectCheckbox);
                leftSection.appendChild(completionCheckbox);
                leftSection.appendChild(taskContent);

                const btnContainer = document.createElement('div');
                btnContainer.className = 'flex gap-2 w-full sm:w-auto';

                const editBtn = document.createElement('button');
                editBtn.className = 'flex-1 sm:flex-none px-4 sm:px-3 py-2 sm:py-1.5 bg-yellow-100 dark:bg-yellow-900/30 text-yellow-700 dark:text-yellow-300 rounded-lg hover:bg-yellow-200 dark:hover:bg-yellow-900/50 transition-colors duration-200 text-sm font-medium touch-manipulation min-h-[44px] sm:min-h-0';
                editBtn.textContent = '✏️ 編集';
                editBtn.addEventListener('click', () => editTask(i, task));

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'flex-1 sm:flex-none px-4 sm:px-3 py-2 sm:py-1.5 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300 rounded-lg hover:bg-red-200 dark:hover:bg-red-900/50 transition-colors duration-200 text-sm font-medium touch-manipulation min-h-[44px] sm:min-h-0';
                deleteBtn.textContent = '🗑️ 削除';
                deleteBtn.addEventListener('click', () => deleteTask(i));

                btnContainer.appendChild(editBtn);
                btnContainer.appendChild(deleteBtn);

                wrapper.appendChild(leftSection);
                wrapper.appendChild(btnContainer);
                li.appendChild(wrapper);

                // Make task draggable if drag and drop is enabled
                makeTaskDraggable(li, task, i);

                list.appendChild(li);
            });
            
            // Reset selection state after updating tasks
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            }
            const bulkActionsBar = document.getElementById('bulkActionsBar');
            if (bulkActionsBar) {
                bulkActionsBar.classList.add('hidden');
            }
            
            // Clear keyboard navigation selection when tasks are updated
            clearTaskSelection();
            
            } catch (error) {
                ErrorHandler.handleApiError(error, 'fetchTasks');
            }
        }
        async function addTask() {
            const input = document.getElementById('newTask');
            const prioritySelect = document.getElementById('prioritySelect');
            const dueDateInput = document.getElementById('dueDateInput');
            const categoryInput = document.getElementById('categoryInput');
            const task = input.value.trim();
            const priority = prioritySelect.value;
            const dueDate = dueDateInput.value || null;
            const category = categoryInput.value.trim() || null;
            
            if (!task) {
                ErrorHandler.showWarning('タスクの内容を入力してください');
                input.focus();
                return;
            }
            
            if (task.length > 200) {
                ErrorHandler.showWarning('タスクの内容は200文字以内で入力してください');
                input.focus();
                return;
            }
            
            try {
                const requestBody = { text: task, priority };
                if (dueDate) {
                    requestBody.due_date = dueDate;
                }
                if (category) {
                    requestBody.category = category;
                }
                
                const res = await ErrorHandler.fetchWithRetry('/tasks', { 
                    method: 'POST', 
                    headers: getAuthHeaders(), 
                    body: JSON.stringify(requestBody) 
                });
                
                input.value = '';
                prioritySelect.value = 'medium';
                dueDateInput.value = '';
                categoryInput.value = '';
                
                ErrorHandler.showSuccess('タスクを追加しました');
                fetchTasks();
            } catch (error) {
                ErrorHandler.handleApiError(error, 'addTask');
            }
        }
        async function deleteTask(index) {
            try {
                // Get the task ID from the DOM element
                const taskElement = document.querySelectorAll('#taskList li')[index];
                const taskId = parseInt(taskElement.dataset.taskId);
                
                if (!taskId) {
                    ErrorHandler.showError('タスクIDが見つかりません');
                    return;
                }
                
                const res = await ErrorHandler.fetchWithRetry(`/tasks/${taskId}`, { 
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${BEARER_TOKEN}` }
                });
                
                ErrorHandler.showSuccess('タスクを削除しました');
                fetchTasks();
            } catch (error) {
                ErrorHandler.handleApiError(error, 'deleteTask');
            }
        }
        let currentlyEditingIndex = -1;
        
        async function editTask(index, currentTask) {
            // Prevent multiple simultaneous edits
            if (currentlyEditingIndex !== -1) {
                return;
            }
            
            currentlyEditingIndex = index;
            const taskElement = document.querySelectorAll('#taskList li')[index];
            if (!taskElement) {
                currentlyEditingIndex = -1;
                return;
            }
            
            // Hide the original task content and show inline edit form
            const originalContent = taskElement.innerHTML;
            taskElement.innerHTML = createInlineEditForm(currentTask, index);
            
            // Focus on the text input
            const textInput = taskElement.querySelector('.inline-edit-text');
            if (textInput) {
                textInput.focus();
                textInput.select();
            }
            
            // Set up event handlers for save/cancel
            setupInlineEditHandlers(taskElement, index, currentTask, originalContent);
        }
        
        function createInlineEditForm(task, index) {
            const priorityOptions = [
                { value: 'high', label: '🔴 高', selected: task.priority === 'high' },
                { value: 'medium', label: '🟡 中', selected: task.priority === 'medium' },
                { value: 'low', label: '🟢 低', selected: task.priority === 'low' }
            ].map(opt => `<option value="${opt.value}" ${opt.selected ? 'selected' : ''}>${opt.label}</option>`).join('');
            
            return `
                <div class="bg-blue-50 dark:bg-blue-900/30 border-2 border-blue-300 dark:border-blue-600 rounded-xl p-4 space-y-3 animate-fade-in">
                    <div class="text-sm font-medium text-blue-800 dark:text-blue-300 mb-3">タスクを編集</div>
                    
                    <!-- Task Text -->
                    <div>
                        <label class="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">タスク内容</label>
                        <input type="text" 
                               class="inline-edit-text w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none text-sm"
                               value="${task.text.replace(/"/g, '&quot;')}"
                               maxlength="200">
                    </div>
                    
                    <!-- Priority and Completion Status Row -->
                    <div class="flex flex-col sm:flex-row gap-3">
                        <div class="flex-1">
                            <label class="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">優先度</label>
                            <select class="inline-edit-priority w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none text-sm">
                                ${priorityOptions}
                            </select>
                        </div>
                        <div class="flex-1">
                            <label class="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">完了状態</label>
                            <select class="inline-edit-completed w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none text-sm">
                                <option value="false" ${!task.completed ? 'selected' : ''}>未完了</option>
                                <option value="true" ${task.completed ? 'selected' : ''}>完了</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Due Date and Category Row -->
                    <div class="flex flex-col sm:flex-row gap-3">
                        <div class="flex-1">
                            <label class="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">期限日</label>
                            <input type="date" 
                                   class="inline-edit-due-date w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none text-sm"
                                   value="${task.due_date || ''}">
                        </div>
                        <div class="flex-1">
                            <label class="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">カテゴリ</label>
                            <input type="text" 
                                   class="inline-edit-category w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none text-sm"
                                   value="${task.category || ''}"
                                   placeholder="カテゴリ名"
                                   maxlength="50">
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="flex flex-col sm:flex-row gap-2 pt-2">
                        <button class="inline-edit-save flex-1 sm:flex-none px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition-colors duration-200 text-sm font-medium touch-manipulation min-h-[44px] sm:min-h-0">
                            ✓ 保存
                        </button>
                        <button class="inline-edit-cancel flex-1 sm:flex-none px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg transition-colors duration-200 text-sm font-medium touch-manipulation min-h-[44px] sm:min-h-0">
                            ✕ キャンセル
                        </button>
                    </div>
                </div>
            `;
        }
        
        function setupInlineEditHandlers(taskElement, index, originalTask, originalContent) {
            const saveBtn = taskElement.querySelector('.inline-edit-save');
            const cancelBtn = taskElement.querySelector('.inline-edit-cancel');
            const textInput = taskElement.querySelector('.inline-edit-text');
            
            // Save handler
            const saveHandler = async () => {
                await saveInlineEdit(taskElement, index, originalTask);
            };
            
            // Cancel handler
            const cancelHandler = () => {
                cancelInlineEdit(taskElement, originalContent);
            };
            
            // Keyboard handlers
            const keyHandler = (e) => {
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    saveHandler();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelHandler();
                }
            };
            
            // Add event listeners
            saveBtn.addEventListener('click', saveHandler);
            cancelBtn.addEventListener('click', cancelHandler);
            textInput.addEventListener('keydown', keyHandler);
            
            // Also add keydown to other inputs for escape functionality
            const inputs = taskElement.querySelectorAll('input, select');
            inputs.forEach(input => {
                input.addEventListener('keydown', keyHandler);
            });
        }
        
        async function saveInlineEdit(taskElement, index, originalTask) {
            const textInput = taskElement.querySelector('.inline-edit-text');
            const prioritySelect = taskElement.querySelector('.inline-edit-priority');
            const completedSelect = taskElement.querySelector('.inline-edit-completed');
            const dueDateInput = taskElement.querySelector('.inline-edit-due-date');
            const categoryInput = taskElement.querySelector('.inline-edit-category');
            
            const newText = textInput.value.trim();
            const newPriority = prioritySelect.value;
            const newCompleted = completedSelect.value === 'true';
            const newDueDate = dueDateInput.value || null;
            const newCategory = categoryInput.value.trim() || null;
            
            // Validate inputs
            if (!newText) {
                ErrorHandler.showWarning('タスクの内容を入力してください');
                textInput.focus();
                textInput.classList.add('border-red-500');
                setTimeout(() => textInput.classList.remove('border-red-500'), 3000);
                return;
            }
            
            if (newText.length > 200) {
                ErrorHandler.showWarning('タスクの内容は200文字以内で入力してください');
                textInput.focus();
                return;
            }
            
            // Check if anything actually changed
            const hasChanges = newText !== originalTask.text || 
                             newPriority !== originalTask.priority ||
                             newCompleted !== originalTask.completed ||
                             newDueDate !== originalTask.due_date ||
                             newCategory !== originalTask.category;
            
            if (!hasChanges) {
                cancelInlineEdit(taskElement, null);
                return;
            }
            
            // Show loading state
            const saveBtn = taskElement.querySelector('.inline-edit-save');
            const originalSaveText = saveBtn.textContent;
            saveBtn.textContent = '保存中...';
            saveBtn.disabled = true;
            
            try {
                const requestBody = { 
                    text: newText, 
                    priority: newPriority, 
                    completed: newCompleted 
                };
                
                if (newDueDate !== undefined) {
                    requestBody.due_date = newDueDate;
                }
                if (newCategory !== undefined) {
                    requestBody.category = newCategory;
                }
                
                // Get the task ID from the original task
                const taskId = originalTask.id;
                const res = await ErrorHandler.fetchWithRetry(`/tasks/${taskId}`, { 
                    method: 'PUT', 
                    headers: getAuthHeaders(), 
                    body: JSON.stringify(requestBody) 
                });
                
                // Reset editing state and refresh tasks
                currentlyEditingIndex = -1;
                ErrorHandler.showSuccess('タスクを更新しました');
                await fetchTasks();
                
            } catch (error) {
                ErrorHandler.handleApiError(error, 'saveInlineEdit');
                
                // Restore save button
                saveBtn.textContent = originalSaveText;
                saveBtn.disabled = false;
            }
        }
        
        function cancelInlineEdit(taskElement, originalContent) {
            currentlyEditingIndex = -1;
            if (originalContent) {
                taskElement.innerHTML = originalContent;
                
                // Re-setup event handlers for the restored buttons
                const editBtn = taskElement.querySelector('button[onclick*="editTask"]');
                const deleteBtn = taskElement.querySelector('button[onclick*="deleteTask"]');
                if (editBtn && deleteBtn) {
                    // The onclick handlers are restored with innerHTML, so no need to re-add them
                }
            } else {
                // If no original content, refresh the tasks
                fetchTasks();
            }
        }
        
        // Enter key support for adding tasks
        document.addEventListener('DOMContentLoaded', function() {
            const input = document.getElementById('newTask');
            input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addTask();
                }
            });
            
            // パフォーマンス最適化を初期化
            PerformanceOptimizer.init();
            
            // 初期のソート順に基づいてドラッグ&ドロップを設定
            const sortOrder = document.getElementById('sortOrder').value;
            isDragAndDropEnabled = sortOrder === 'manual';
            console.log('Initial drag and drop enabled:', isDragAndDropEnabled, 'Sort order:', sortOrder);
        });
        fetchTasks();
    </script>
</body>
</html>
